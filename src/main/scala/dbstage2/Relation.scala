package dbstage2

import Embedding.Predef._
import squid.lib.transparencyPropagating
//import shapeless.HList
import squid.utils._
import shapeless._
import scala.language.higherKinds

// FIXME make AutoKeyedRelation[K,T] extend Relation[T] (hide auto-key) ? â€“ have a second type that lists all fields...
// TODO in Squid: a codeType constructor/extractor QQ; they should match invariantly!

//class Relation[T<:Record](primaryKeys: Set[List[FieldModule]]=Set()) {
//sealed abstract case class 
//sealed class Relation[T<:Record:CodeType]
sealed class Relation[T:CodeType] // TODO an implicit to prove that T<:<Record, just so as to restrict the possibilities
(private[dbstage2] val primaryKeyTypes: Set[CodeType[_]],
 val columnStore: Bool = false
 //) extends Variable[Relation[T]] {
) extends SelfAssignedVariable[Relation[T]] {
  
  // code"Option.empty[$tp]"
  private def decomposePrimaryKeyType(tp: CodeType[_]): List[CodeType[_]] =
    /*base debugFor*/ {
    //println(s"Matching $tp")
    //code"??? : $tp" match {
    code"Set.empty[$tp]" match { // Note: using code"??? : ($hd :: $tl)" doesn't work, as it extracts Nothing for `hd` and `tl`!!
    //case code"??? : ($hd :: $tl)" => 
    //case code"??? : dbstage.::[$hd,$tl]" => 
    case code"Set.empty[$hd :: $tl]" => // case code"Set.empty[dbstage.::[$hd,$tl]]" => 
      //println(tp,hd,tl)
      //System.in.read()
      hd :: decomposePrimaryKeyType(tl)
    //case code"??? : $tp" => tp :: Nil
    //case _ => tp :: Nil
    case code"Set.empty[NoFields]" => Nil
    case _ => lastWords(s"Type $tp does not appear to be an inspectable Record type...")
  }}
  lazy val primaryKeys = primaryKeyTypes map decomposePrimaryKeyType
  
  def withPrimaryKey[K<:FieldModule:CodeType](implicit p: T Project (K::NoFields)) = withPrimaryKeys[K::NoFields]
  def withPrimaryKeys[Ks<:Record:CodeType](implicit p: T Project Ks) = {
    //println(p)
    //println(p,codeTypeOf[Ks])
    //Relation[T]
    new Relation[T](primaryKeyTypes + codeTypeOf[Ks])
  }
  //def withForeighKey[S<:Record,K<:Record](r: Relation[S])(implicit p0: T Project K, p1: S Project K) = {
  //  Relation[T]
  //}
  //case class withForeighKey[K<:Record] {
  def withForeighKey[K<:FieldModule] = new withForeighKey[K::NoFields]
  def withForeighKeys[K<:Record] = new withForeighKey[K]
  class withForeighKey[K<:Record] {
    def apply[S<:Record](r: Relation[S])(implicit p0: T Project K, p1: S Project K) = Relation[T]()
  }
  
  //def withAutoGeneratedKey[K<:Field[Int]] = Relation[K::T]
  //def withAutoGeneratedKey[K<:Field[Int]]: AutoKeyedRelation[K,T,Relation[T]] = new AutoKeyedRelation[K,T,Relation[T]]
  def withAutoGeneratedKey[K<:Field[Int]:CodeType]: AutoKeyedRelation[K,T] = new AutoKeyedRelation[K,T](this)
  //def +=(t: T) = this
  def addTuple_!(t: T) = this
  
  //def filter(pred: T => Bool): Query = new Query // TODO
  @transparencyPropagating
  def query: Query[T] = Scan(this)
  @transparencyPropagating
  //def queryHK: QueryHK.PlainQuery[T] = ScanHK(this)
  //def queryHK: PlainQuery.Query[T,Any] = PlainQuery.Scan(this)
  //def queryHK(implicit T: PlainQuery.base.CodeType[T]): PlainQuery.Query[T,Any] = PlainQuery.Scan(this)
  def queryHK: PlainQuery.Query[T,Any] = PlainQuery.Scan(this)(PlainQuery.base.CodeType(null))
  
  //val self = new Variable[this.type]
  
  /*
  //def compileQuery(q: Code[this.type,Any] => Code[QueryPlan,Any]) = {
  //def compileQuery(q: ClosedCode[this.type] => ClosedCode[QueryPlan]) = {
  def compileQuery(q: Code[this.type,self.Ctx] => Code[QueryPlan,self.Ctx]) = {
    println(self)
    //val self = new Variable[Relation[T]].asInstanceOf[Variable[this.type]]
    println(q(self.toCode))
  }
  */
  
  override def toString: String = s"Relation[${codeTypeOf[T].rep}](primaryKeys=${primaryKeyTypes})"
}
object Relation {
  //def apply[T<:Record:CodeType](columnStore: Bool = false) = new Relation[T](Set(), columnStore=columnStore)
  def apply[T:CodeType](columnStore: Bool = false) = new Relation[T](Set(), columnStore=columnStore)
}
//class AutoKeyedRelation[AK<:Field[Int],T<:Record,Base<:Relation[T]](base:Base) extends Relation[AK::T] {
//class AutoKeyedRelation[AK<:Field[Int]:CodeType,T<:Record:CodeType](base:Relation[T]) 
class AutoKeyedRelation[AK<:Field[Int]:CodeType,T:CodeType](base:Relation[T]) 
  extends Relation[AK::T](base.primaryKeyTypes + codeTypeOf[AK::NoFields], columnStore=base.columnStore) {
  //def +=(t: T) = base += t
  def addValue_!(t: T) = base addTuple_! t // no
}

/*
sealed abstract class Fields extends Query
case class Field[T](name: String, isPrimaryKey: Bool = false) extends Record
//case class ~[T] (head: Field[T], rest: Fields) extends Fields
abstract class FieldsCons extends Record {
  type Head
  val head: Field[Head]
  val rest: Record
}

abstract class Relation {
  //val * : Fields
  val * : HList
}

sealed abstract trait Query {
  
}
*/

/*
sealed abstract class RowRep[A]
case class RowRepBase[A:IRType]() extends RowRep[A]
//case class RowRepExt[A:IRType,B](rest: RowRep[B])
//case class RowRepExt[A,B](head: RowRep[A], tail: RowRep[B]) extends RowRep[A]
//case class RowRepExt[T0:IRType,T1 <: HList:RowRep]() extends RowRep[T0 :: T1]
case class RowRepExt[T0,T1 <: HList](implicit val T0: RowRep[T0], implicit val T1: RowRep[T1]) extends RowRep[T0 :: T1]

class Rel[T:RowRep]
*/

